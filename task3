`timescale 1ns/1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 07/21/2025 02:44:37 PM
// Design Name: 
// Module Name: task3
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module pipeline_processor(input clk, input reset);

    // === Program Counter ===
    reg [7:0] PC = 0;

    // === Instruction Memory ===
    reg [15:0] instr_mem[0:255];
    initial begin
        // Format: opcode[15:12] | rd[11:8] | rs1[7:4] | rs2/imm[3:0]
        instr_mem[0] = 16'b0001000100100011; // ADD R1 = R2 + R3
        instr_mem[1] = 16'b0010001000010101; // SUB R2 = R1 - R5
        instr_mem[2] = 16'b0011011000000001; // LOAD R6 = mem[1] (mocked)
    end

    // === Register File ===
    reg [7:0] reg_file[0:15];
    initial begin
        reg_file[2] = 8'd10;  // R2
        reg_file[3] = 8'd5;   // R3
        reg_file[1] = 8'd0;   // R1
        reg_file[5] = 8'd3;   // R5
    end

    // === Pipeline Registers ===
    reg [15:0] IF_ID_instr;
    reg [3:0] ID_EX_opcode, ID_EX_rd;
    reg [7:0] ID_EX_op1, ID_EX_op2;
    reg [3:0] EX_WB_rd;
    reg [7:0] EX_WB_result;
    reg       EX_WB_we;

    // === Wires for decoded instruction ===
    wire [3:0] opcode = IF_ID_instr[15:12];
    wire [3:0] rd     = IF_ID_instr[11:8];
    wire [3:0] rs1    = IF_ID_instr[7:4];
    wire [3:0] rs2    = IF_ID_instr[3:0];

    // === Register Reads ===
    wire [7:0] reg_data1 = reg_file[rs1];
    wire [7:0] reg_data2 = reg_file[rs2];

    // === Instruction Fetch (IF) ===
    wire [15:0] current_instr = instr_mem[PC];
    always @(posedge clk)
        if (!reset) PC <= PC + 1;

    // === IF/ID Pipeline Register ===
    always @(posedge clk)
        IF_ID_instr <= current_instr;

    // === Instruction Decode (ID) ===
    always @(posedge clk) begin
        ID_EX_opcode <= opcode;
        ID_EX_rd     <= rd;
        ID_EX_op1    <= reg_data1;
        ID_EX_op2    <= reg_data2;
    end

    // === Execute (EX) ===
    reg [7:0] alu_result;
    always @(*) begin
        case (ID_EX_opcode)
            4'b0001: alu_result = ID_EX_op1 + ID_EX_op2;   // ADD
            4'b0010: alu_result = ID_EX_op1 - ID_EX_op2;   // SUB
            4'b0011: alu_result = 8'hAB;                   // LOAD (mocked memory value)
            default: alu_result = 8'h00;
        endcase
    end

    // === EX/WB Pipeline Register ===
    always @(posedge clk) begin
        EX_WB_rd     <= ID_EX_rd;
        EX_WB_result <= alu_result;
        EX_WB_we     <= 1; // Always enable write back
    end

    // === Write Back (WB) ===
    always @(posedge clk)
        if (EX_WB_we)
            reg_file[EX_WB_rd] <= EX_WB_result;

    // === Debug Monitoring ===
    always @(posedge clk) begin
        $display("Time: %0t | PC=%d | Instr=%b | R1=%d R2=%d R3=%d R5=%d R6=%d", 
            $time, PC, current_instr, reg_file[1], reg_file[2], reg_file[3], reg_file[5], reg_file[6]);
    end

endmodule


#TEST BENCH

`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date: 07/21/2025 02:46:56 PM
// Design Name: 
// Module Name: task3_tb
// Project Name: 
// Target Devices: 
// Tool Versions: 
// Description: 
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module tb_pipeline;

    reg clk;
    reg reset;

    // Instantiate the DUT (Device Under Test)
    pipeline_processor uut (
        .clk(clk),
        .reset(reset)
    );

    // Generate clock: toggle every 5ns => 10ns period
    always #5 clk = ~clk;

    initial begin
        // Initialize signals
        clk = 0;
        reset = 1;

        // Hold reset for a few cycles
        #15 reset = 0;

        // Run simulation for enough time to allow pipeline processing
        #200 $finish;
    end

    // Optional: Dump waveform for GTKWave
    initial begin
        $dumpfile("pipeline.vcd");
        $dumpvars(0, tb_pipeline);
    end

endmodule
